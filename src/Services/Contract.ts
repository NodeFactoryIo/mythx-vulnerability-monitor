import * as solc from 'solc';
import Analysis, { status } from '../Models/Analysis';
import Contract from '../Models/Contract';
import MythX from "./MythX";
import Mail from "./Mail";

class ContractService {
    private loadSolcVersion(version, callback) : Promise<any> {
        return new Promise((resolve, reject) => {
            solc.loadRemoteVersion(version, function (err, solcSnapshot) {
                if (err) {
                    console.error(err);
                    reject(err);
                } else {
                    const response = callback(solcSnapshot);
                    resolve(response);
                }
            });
        })
    }

    private solcCompile(solcVersioned, name, source) {
        const input = {
            language: 'Solidity',
            sources: {
                [name]: {
                    content: JSON.parse(source)
                }
            },
            settings: {
                outputSelection: {
                    '*': {
                        '*': [ '*' ]
                    }
                }
            }
        };
        return JSON.parse(solcVersioned.compile(JSON.stringify(input)))
    }

    private parseCompilerOutput(contractName, output) {
        const { contracts, sources } = output;
        const fullName = contractName.includes('.sol') ? contractName : `${contractName}.sol`;
        const contract = contracts[fullName][contractName];

        return {
            contractName,
            bytecode: contract.evm.bytecode.object,
            deployedBytecode: contract.evm.deployedBytecode.object,
            sourceMap: contract.evm.bytecode.sourceMap,
            deployedSourceMap: contract.evm.deployedBytecode.sourceMap,
            version: JSON.parse(contract.metadata).compiler.version,
            sourceList: Object.keys(sources),
        }
    }

    public async compile(name, source) {
        const fullName = name.includes('.sol') ? name : `${name}.sol`;
        const output = await this.loadSolcVersion('v0.4.24+commit.e67f0147',
            (compiler) => this.solcCompile(compiler, fullName, source));

        return this.parseCompilerOutput(name, output);
    }

    public async storeContract(data) {
        const { bytecode, deployedBytecode, sourceMap, deployedSourceMap, sourceList, source, userId, name, address } = data;

        return Contract.create({
            bytecode,
            deployedBytecode,
            sourceMap,
            deployedSourceMap,
            sourceList,
            source,
            name,
            userId,
            address,
        });
    }

    public async submitForAnalysis(access, data) {
        const { bytecode, name, source, address, userId } = data;

        let response, contract;
        if (source) {
            // Make full analysis
            const compiled = await this.compile(name, source);
            // Check if bytecode matches?
            response = await MythX.submitContractForFullAnalysis(compiled, source, name, access);
            contract = await this.storeContract({
                ...compiled,
                source,
                userId,
                name,
                address,
            });
        } else {
            // Send bytecode only for analysis
            response = await MythX.submitContractForBytecodeAnalysis(bytecode, access);
            contract = await this.storeContract({ bytecode, address, userId });
        }

        return this.storeAnalysisSubmission(response.uuid, contract.id, access);
    }

    public async storeAnalysisSubmission(uuid, contractId, access) {
        return Analysis.create({
            uuid,
            contractId,
            accessToken: access,
            status: status.SUBMITTED,
        })
    }

    private async notifyAnalysisResult(email) {
        const apiURL = process.env.API_URL || 'http://localhost:3000/api';
        const data = {
            reportURL: `${apiURL}/analyses?email=${email}`,
        };

        return Mail.sendReport(email, data);
    }

    public async checkAnalysisResult(analysis : Analysis) {
        try {
            const user = await Contract.getContractOwner(analysis.contractId);
            const response = await MythX.getAnalysisStatus(analysis.uuid, user.accessToken);

            if (response.status === 'Finished') {
                const result = await MythX.getAnalysisResult(analysis.uuid, user.accessToken);
                await analysis.update({
                    report: JSON.stringify(result[0].issues),
                    status: status.FINISHED,
                });
                await this.notifyAnalysisResult(user.email);
            } else if (response.status === 'Error') {
                const result = await MythX.getAnalysisResult(analysis.uuid, user.accessToken);
                await analysis.update({
                    report: JSON.stringify(result[0].issues),
                    status: status.ERROR,
                });
                await this.notifyAnalysisResult(user.email);
            } else {
                await analysis.update({ status: status.RUNNING });
            }
        } catch (error) {
            console.error(error);
            console.error(`Error while checking analysis... ${error.message}`);
        }
    }
}

export default new ContractService();