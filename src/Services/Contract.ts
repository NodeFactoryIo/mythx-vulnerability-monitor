import * as solc from 'solc';
import Analysis from '../Models/Analysis';
import Contract from '../Models/Contract';

class ContractService {
    private loadSolcVersion(version, callback) : Promise<any> {
        return new Promise((resolve, reject) => {
            solc.loadRemoteVersion(version, function (err, solcSnapshot) {
                if (err) {
                    console.error(err);
                    reject(err);
                } else {
                    const response = callback(solcSnapshot);
                    resolve(response);
                }
            });
        })
    }

    private solcCompile(solcVersioned, name, source) {
        const input = {
            language: 'Solidity',
            sources: {
                [name]: {
                    content: JSON.parse(source)
                }
            },
            settings: {
                outputSelection: {
                    '*': {
                        '*': [ '*' ]
                    }
                }
            }
        };
        return JSON.parse(solcVersioned.compile(JSON.stringify(input)))
    }

    private parseCompilerOutput(contractName, output) {
        const { contracts, sources } = output;
        const fullName = contractName.includes('.sol') ? contractName : `${contractName}.sol`;
        const contract = contracts[fullName][contractName];

        return {
            contractName,
            bytecode: contract.evm.bytecode.object,
            deployedBytecode: contract.evm.deployedBytecode.object,
            sourceMap: contract.evm.bytecode.sourceMap,
            deployedSourceMap: contract.evm.deployedBytecode.sourceMap,
            version: JSON.parse(contract.metadata).compiler.version,
            sourceList: Object.keys(sources),
        }
    }

    public async compile(name, source) {
        const fullName = name.includes('.sol') ? name : `${name}.sol`;
        const output = await this.loadSolcVersion('v0.4.24+commit.e67f0147',
            (compiler) => this.solcCompile(compiler, fullName, source));

        return this.parseCompilerOutput(name, output);
    }

    public async storeContract(data) {
        const { bytecode, deployedBytecode, sourceMap, deployedSourceMap, sourceList, source, userId, name, address } = data;
        // TODO: Add other compilation data in db

        return Contract.create({
            bytecode,
            deployedBytecode,
            sourceMap,
            deployedSourceMap,
            sourceList,
            source,
            name,
            userId,
            address
        });
    }

    public async storeUuid(uuid, contractId) {
        return Analysis.create({
            uuid,
            contractId,
        })
    }
}

export default new ContractService();