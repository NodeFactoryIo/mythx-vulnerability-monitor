import * as jwtDecode from "jwt-decode";
import User from "../Models/User";
import MythX from "./MythX";

export default class Auth {
    public static async saveTokens(email: string, accessToken: string, refreshToken: string) {
        return User.findOne({ where: { email }})
            .then((user) => {
                return user ?
                    user.update({ accessToken, refreshToken })
                    : User.create({ accessToken, refreshToken, email });
            });
    }

    public static getToken(userId : number) : Promise<string> {
        return new Promise(async (resolve, reject) => {
            try {
                const user = await User.findById(userId);
                const token = jwtDecode(user.accessToken);
                const currentTime = new Date().getTime() / 1000;

                if (token.exp <= currentTime) {
                    const updatedUser = await Auth.refreshToken(user);
                    resolve(updatedUser.accessToken);
                } else {
                    console.log('Not going to refresh token, still valid.');
                    resolve(user.accessToken);
                }
            } catch (error) {
                error.message ? reject(error.message) : reject(error);
                // TODO: Assign this token as invalid on error including invalid tokens
            }
        });
    }

    public static refreshToken(user : User) : Promise<User> {
        return new Promise(async (resolve, reject) => {
            try {
                const response = await MythX.refreshTokenRequest(user.accessToken, user.refreshToken);
                if (response.access && response.refresh) {
                    console.log('Going to save those tokens');
                    const result = await Auth.saveTokens(user.email, response.access, response.refresh);
                    console.log('Saving done');
                    resolve(result);
                } else {
                    reject('Tokens not refreshed');
                }
            } catch (error) {
                error.message ? reject(error.message) : reject(error);
                // TODO: Assign this token as invalid on error including invalid tokens
            }
        });
    }
}
