import * as jwtDecode from "jwt-decode";
import User from "../Models/User";
import MythX from "./MythX";

export default class Auth {
    public static async saveTokens(email: string, accessToken: string, refreshToken: string) {
        return User.findOne({ where: { email }})
            .then((user) => {
                return user ?
                    user.update({ accessToken, refreshToken })
                    : User.create({ accessToken, refreshToken, email });
            });
    }

    public static refreshToken(user : User) {
        return new Promise(async (resolve, reject) => {
            try {
                // const user = await User.findByPk(email);
                const token = jwtDecode(user.accessToken);
                const currentTime = new Date().getTime() / 1000;
                const diff = token.exp - currentTime;
                // Refresh only if less than 5 minutes left to live
                if (diff > 0  && diff <= 5 * 60) {
                    const response = await MythX.refreshTokenRequest(user.accessToken, user.refreshToken);
                    if (response.access && response.refresh) {
                        await Auth.saveTokens(user.email, response.access, response.refresh);
                        resolve();
                    } else {
                        reject('Tokens not refreshed');
                    }
                } else {
                    console.log(`Skipping token... Left ${diff/60} minutes`);
                }
            } catch (error) {
                reject(error.message);
                // TODO: Assign this token as invalid on error including invalid tokens
            }
        });
    }
}
