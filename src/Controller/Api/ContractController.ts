import { Request, Response } from "express";
import { body, validationResult } from 'express-validator/check';
import Contract from "../../Services/Contract";
import MythX from "../../Services/MythX";
import User from '../../Models/User';

export default class ContractController {

    public static validationSubmitContract = [
        body('bytecode').exists().trim(),
        body('access').exists().trim(),
        // body('source').custom((value, { req }) => {
        //     if (value && !req.body.name) {
        //         throw new Error('Contract name is required with source');
        //     }
        // }),
    ];

    public static async submitContract(req: Request, res: Response): Promise<Response> {
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            return res.status(400).json({ errors: errors.array() });
        }

        try {
            const { bytecode, name, source, access, address } = req.body;
            const user = await User.findByAccess(access);

            if (!user) {
                return res.status(401).send('Not logged in');
            }

            let response, contract;
            if (source) {
                // Make full analysis
                const compiled = await Contract.compile(name, source);
                // Check if bytecode matches?
                response = await MythX.submitContractForFullAnalysis(compiled, source, name, access);
                contract = await Contract.storeContract({
                    ...compiled,
                    source,
                    userId: user.id,
                    name,
                    address,
                });
            } else {
                // Send bytecode only for analysis
                response = await MythX.submitContractForBytecodeAnalysis(bytecode, access);
                contract = await Contract.storeContract({ bytecode, address, userId: user.id });
            }

            Contract.storeUuid(response.uuid, contract.id);
            res.status(200).send(response);
        } catch (error) {
            console.error(error);
            return res.status(500).send(error);
        }

    }

}
