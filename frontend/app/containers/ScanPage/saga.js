import {
  put, takeLatest, call, select, take
} from 'redux-saga/effects';
import { ethers } from 'ethers';
import { API_CONTRACT_URL, CONTRACT_CREATION_TX } from '../../api';
import { getRequest, postRequest } from '../../utils/request';
import { makeSelectToken } from '../App/selectors';
import { makeSelectBytecode } from './selectors';
import {
  bytecodeFetchSuccess, bytecodeFetchError, submitContractSuccess, submitContractError
} from './actions';

import { SAVE_TOKENS_SUCCESS } from '../Login/constants';
import {
  CHANGE_STEP,
  BYTECODE_FETCH_REQUEST,
  SUBMIT_CONTRACT_REQUEST,
  BYTECODE_FETCH_SUCCESS,
  FETCH_COMPILERS_SUCCESS, FETCH_COMPILERS_ERROR
} from './constants';

function* smartContractEntry() {
  yield put({ type: CHANGE_STEP, next: 1 });
}

function* bytecodeRequest(action) {
  try {
    // Fetch creation transaction
    const { contractAddress } = action;
    const url = CONTRACT_CREATION_TX.replace(':address', contractAddress);

    const response = yield call(getRequest, url);
    const { data } = response;

    // Fetch bytecode
    const txHash = data.id;
    const provider = ethers.getDefaultProvider();
    const result = yield provider.getTransaction(txHash);
    yield put(bytecodeFetchSuccess(result.data));
  } catch (error) {
    const errorMessage = error.response || error;
    yield put(bytecodeFetchError(errorMessage));
  }
}

function* fetchCompilerVersions(action) {
  if (action.next === 1) {
    try {
      const response = yield call(getRequest, 'https://ethereum.github.io/solc-bin/bin/list.json');
      const compilerVersions = Object.values(response.releases)
        .map((release) => release.replace('soljson-', '').replace('.js', ''));

      yield put({ type: FETCH_COMPILERS_SUCCESS, compilerVersions });
    } catch (e) {
      yield put({ type: FETCH_COMPILERS_ERROR, error: e });
    }
  }
}

function* submitContract(action) {
  const { contractAddress, source, name, compilerVersion } = action;

  try {
    yield put({ type: BYTECODE_FETCH_REQUEST, contractAddress });
    yield take(BYTECODE_FETCH_SUCCESS);

    const bytecode = yield select(makeSelectBytecode());
    const access = yield select(makeSelectToken());

    const body = {
      bytecode,
      access,
      address: contractAddress,
    };
    if (source) {
      body.source = JSON.stringify(source);
      body.name = name;
      body.compilerVersion = compilerVersion;
    }

    const response = yield call(postRequest, API_CONTRACT_URL, { body });
    yield put(submitContractSuccess(response));
  } catch (error) {
    yield put(submitContractError(error.response));
  }
}

export default function* contract() {
  yield takeLatest(SAVE_TOKENS_SUCCESS, smartContractEntry);
  yield takeLatest(BYTECODE_FETCH_REQUEST, bytecodeRequest);
  yield takeLatest(SUBMIT_CONTRACT_REQUEST, submitContract);
  yield takeLatest(CHANGE_STEP, fetchCompilerVersions);
}
